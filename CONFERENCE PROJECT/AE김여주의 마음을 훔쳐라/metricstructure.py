# -*- coding: utf-8 -*-
"""MetricStructure

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f-g8U4-sDNzbV9VYZd2ZeC6OysTuMOPc

## **감정 레이블 별 호감도 점수 메트릭**
"""

# 필요한 라이브러리 설치
!pip install mxnet
!pip install gluonnlp pandas tqdm
!pip install sentencepiece
!pip install transformers
!pip install torch

# 토크나이저 파일 로드
!pip install 'git+https://github.com/SKTBrain/KoBERT.git#egg=kobert_tokenizer&subdirectory=kobert_hf'

from kobert_tokenizer import KoBERTTokenizer
from transformers import BertModel
from sklearn.metrics.pairwise import cosine_similarity
import torch
import numpy as np

# KoBERT 모델과 토크나이저 불러오기
tokenizer = KoBERTTokenizer.from_pretrained('skt/kobert-base-v1')
model = BertModel.from_pretrained('skt/kobert-base-v1')

# 단어 임베딩 함수
def get_embedding(word):
    inputs = tokenizer(word, return_tensors='pt')
    outputs = model(**inputs)
    return outputs.last_hidden_state.mean(dim=1).detach().numpy()

!pip install datasets

from datasets import load_dataset

# Load the dataset
dataset = load_dataset("searle-j/kote")

# Print details about the dataset
print("Dataset splits:")
for split in dataset.keys():
    print(f"{split} split:")
    print(f"  Number of rows: {dataset[split].num_rows}")
    print(f"  Features: {dataset[split].features}\n")

# 라벨 리스트
LABELS = ['불평/불만', '환영/호의', '감동/감탄', '지긋지긋', '고마움', '슬픔', '화남/분노', '존경', '기대감', '우쭐댐/무시함',
          '안타까움/실망', '비장함', '의심/불신', '뿌듯함', '편안/쾌적', '신기함/관심', '아껴주는', '부끄러움', '공포/무서움', '절망',
          '한심함', '역겨움/징그러움', '짜증', '어이없음', '없음', '패배/자기혐오', '귀찮음', '힘듦/지침', '즐거움/신남', '깨달음',
          '죄책감', '증오/혐오', '흐뭇함(귀여움/예쁨)', '당황/난처', '경악', '부담/안_내킴', '서러움', '재미없음', '불쌍함/연민',
          '놀람', '행복', '불안/걱정', '기쁨', '안심/신뢰']

# 기준 단어 리스트
reference_words = ['설렘', '호감', '관심', '사랑']

# 기준 단어들의 임베딩
reference_embeddings = {word: get_embedding(word) for word in reference_words}

# 모든 라벨과 기준 단어들 간의 유사도 계산
all_similarity_scores = {label: [cosine_similarity(reference_embeddings[word], get_embedding(label))[0][0] for word in reference_words] for label in LABELS}

# 유사도 점수를 내림차순으로 정렬
sorted_similarity_scores = {word: sorted([(label, scores[i]) for label, scores in all_similarity_scores.items()], key=lambda x: x[1], reverse=True) for i, word in enumerate(reference_words)}

# 결과 출력
for word in reference_words:
    print(f"\n'{word}'에 대한 유사도 점수:")
    for label, score in sorted_similarity_scores[word]:
        print(f"{label}: {score}")

# 각 레이블의 유사도 평균 계산
average_similarity_scores = {label: np.mean(scores) for label, scores in all_similarity_scores.items()}

# 유사도 점수를 내림차순으로 정렬하여 평균값 출력
sorted_average_scores = dict(sorted(average_similarity_scores.items(), key=lambda item: item[1], reverse=True))

print("\n각 레이블의 평균 유사도 점수:")
for label, score in sorted_average_scores.items():
    print(f"{label}: {score}")

# 부정적인 감정과 긍정적인 감정을 나누기 위한 리스트
negative_emotions = ['불평/불만', '지긋지긋', '슬픔', '화남/분노', '짜증', '역겨움/징그러움', '공포/무서움',
                     '절망', '한심함', '패배/자기혐오', '귀찮음', '힘듦/지침', '죄책감', '증오/혐오',
                     '재미없음', '서러움', '어이없음', '불쌍함/연민', '경악', '부담/안_내킴', '불안/걱정', '우쭐댐/무시함',
                     '안타까움/실망', '의심/불신']
positive_emotions = ['환영/호의', '감동/감탄', '고마움', '존경', '기대감', '비장함',
                     '뿌듯함', '편안/쾌적', '신기함/관심', '아껴주는', '부끄러움', '흐뭇함(귀여움/예쁨)',
                     '놀람', '행복', '기쁨', '안심/신뢰', '즐거움/신남', '깨달음']

# 부정적인 감정과 긍정적인 감정을 나누어 유사도 점수 저장
negative_similarity_scores = {label: average_similarity_scores[label] for label in negative_emotions if label in average_similarity_scores}
positive_similarity_scores = {label: average_similarity_scores[label] for label in positive_emotions if label in average_similarity_scores}

# 스케일링 함수
def scale_scores(scores, lower_bound, upper_bound):
    min_val = np.min(list(scores.values()))
    max_val = np.max(list(scores.values()))
    return {label: lower_bound + (upper_bound - lower_bound) * (score - min_val) / (max_val - min_val) for label, score in scores.items()}

# 부정적인 감정 점수를 -1에서 0 사이로 스케일링
scaled_negative_scores = scale_scores(negative_similarity_scores, -1, 0)

# 긍정적인 감정 점수를 0에서 1 사이로 스케일링
scaled_positive_scores = scale_scores(positive_similarity_scores, 0, 1)

# 데이터를 오름차순으로 정렬하여 저장
sorted_scaled_negative_scores = dict(sorted(scaled_negative_scores.items(), key=lambda item: item[1]))
sorted_scaled_positive_scores = dict(sorted(scaled_positive_scores.items(), key=lambda item: item[1]))

# 결과 출력
print("\n스케일링된 부정적인 감정 (오름차순 정렬):")
for label, score in sorted_scaled_negative_scores.items():
    print(f"{label}: {score}")

print("\n스케일링된 긍정적인 감정 (오름차순 정렬):")
for label, score in sorted_scaled_positive_scores.items():
    print(f"{label}: {score}")

"""## (사용X) Human Intuition으로 변경된 메트릭"""

# 기존 부정적 감정 라벨과 새 라벨 매핑
negative_emotions_rename = {
    '불안/걱정': '불안/걱정',
    '안타까움/실망': '안타까움/실망',
    '불평/불만': '불평/불만',
    '부담/안_내킴': '부담/안_내킴',
    '화남/분노': '화남/분노',
    '서러움': '서러움',
    '힘듦/지침': '힘듦/지침',
    '의심/불신': '의심/불신',
    '어이없음': '어이없음',
    '우쭐댐/무시함': '우쭐댐/무시함',
    '불쌍함/연민': '불쌍함/연민',
    '공포/무서움': '공포/무서움',
    '귀찮음': '귀찮음',
    '절망': '절망',
    '짜증': '짜증',
    '슬픔': '슬픔',
    '경악': '경악',
    '한심함': '한심함',
    '죄책감': '죄책감',
    '재미없음': '재미없음'
}

# 이름만 바꾼 새로운 순서의 부정 라벨 리스트
negative_emotions_new_order = [
    '지긋지긋', '역겨움/징그러움', '패배/자기혐오', '증오/혐오', '경악', '한심함', '불안/걱정', '안타까움/실망',
    '불평/불만', '부담/안_내킴', '화남/분노', '서러움', '힘듦/지침', '의심/불신', '어이없음', '우쭐댐/무시함',
    '불쌍함/연민', '공포/무서움', '귀찮음', '절망', '짜증', '슬픔', '죄책감', '재미없음'
]


# 기존 긍정 라벨과 새 라벨 매핑
positive_rename = {
    '기대감': '존경',
    '존경': '기대감',
    '흐뭇함(귀여움/예쁨)': '비장함',
    '비장함': '흐뭇함(귀여움/예쁨)'
}

# 부정 라벨 이름 변경 및 점수 유지
for old_label, new_label in negative_emotions_rename.items():
    if old_label in scaled_negative_scores:
        scaled_negative_scores[new_label] = scaled_negative_scores.pop(old_label)

# 부정 라벨을 새로운 순서에 맞게 정렬
scaled_negative_scores_new_ordered = {label: scaled_negative_scores[label] for label in negative_emotions_new_order if label in scaled_negative_scores}

# 결과 출력
print("\n최종 메트릭 부정적인 감정 (오름차순 정렬):")
sorted_scaled_negative_scores = dict(sorted(scaled_negative_scores_new_ordered.items(), key=lambda item: item[1]))
for label, score in sorted_scaled_negative_scores.items():
    print(f"{label}: {score}")

# 긍정 라벨 이름 변경
scaled_positive_scores = {positive_rename.get(label, label): score for label, score in scaled_positive_scores.items()}

print("\n최종 메트릭 긍정적인 감정 (오름차순 정렬):")
sorted_scaled_positive_scores = dict(sorted(scaled_positive_scores.items(), key=lambda item: item[1]))
for label, score in sorted_scaled_positive_scores.items():
    print(f"{label}: {score}")

# 라벨 리스트
LABELS = ['불평/불만', '환영/호의', '감동/감탄', '지긋지긋', '고마움', '슬픔', '화남/분노', '존경', '기대감', '우쭐댐/무시함',
          '안타까움/실망', '비장함', '의심/불신', '뿌듯함', '편안/쾌적', '신기함/관심', '아껴주는', '부끄러움', '공포/무서움', '절망',
          '한심함', '역겨움/징그러움', '짜증', '어이없음', '없음', '패배/자기혐오', '귀찮음', '힘듦/지침', '즐거움/신남', '깨달음',
          '죄책감', '증오/혐오', '흐뭇함(귀여움/예쁨)', '당황/난처', '경악', '부담/안_내킴', '서러움', '재미없음', '불쌍함/연민',
          '놀람', '행복', '불안/걱정', '기쁨', '안심/신뢰']

# '설렘'과 다른 감정 태그의 임베딩
word_embedding = get_embedding('설렘')
emotion_embeddings = {tag: get_embedding(tag) for tag in emotion_tags}

# 유사도 계산
similarity_scores = {tag: cosine_similarity(word_embedding, embedding) for tag, embedding in emotion_embeddings.items()}

similarity_scores

# 유사도 점수 내림차순 정렬
sorted_similarity_scores = sorted(similarity_scores.items(), key=lambda item: item[1], reverse=True)

# 유사도 점수 출력
for label, score in sorted_similarity_scores:
    print(f"{label}: {score}")

# 유사도 점수 오름차순 정렬
sorted_similarity_scores = sorted(similarity_scores.items(), key=lambda item: item[1], reverse=True)

# 부정적인 감정과 긍정적인 감정을 나누기 위한 리스트
negative_emotions = ['불평/불만', '지긋지긋', '슬픔', '화남/분노', '짜증', '역겨움/징그러움', '공포/무서움',
                     '절망', '한심함', '패배/자기혐오', '귀찮음', '힘듦/지침', '죄책감', '증오/혐오',
                     '재미없음', '서러움', '어이없음', '불쌍함/연민', '경악', '부담/안_내킴', '불안/걱정', '우쭐댐/무시함',
                     '안타까움/실망', '의심/불신']
positive_emotions = ['환영/호의', '감동/감탄', '고마움', '존경', '기대감', '비장함',
                     '뿌듯함', '편안/쾌적', '신기함/관심', '아껴주는', '부끄러움', '흐뭇함(귀여움/예쁨)',
                     '놀람', '행복', '기쁨', '안심/신뢰', '즐거움/신남', '깨달음']

# 부정적인 감정과 긍정적인 감정을 나누어 유사도 점수 출력
negative_similarity_scores = {label: score for label, score in sorted_similarity_scores if label in negative_emotions}
positive_similarity_scores = {label: score for label, score in sorted_similarity_scores if label in positive_emotions}

print("부정적인 감정:")
for label, score in negative_similarity_scores.items():
    print(f"{label}: {score}")

print("\n긍정적인 감정:")
for label, score in positive_similarity_scores.items():
    print(f"{label}: {score}")

# 유사도 값을 1D numpy array로 변환
similarity_values = np.array([score.item() for score in similarity_scores.values()])

# 유사도 값을 0에서 1 사이로 정규화
min_val = np.min(similarity_values)
max_val = np.max(similarity_values)

normalized_scores = (similarity_values - min_val) / (max_val - min_val)

# 정규화된 값을 -1에서 1 사이로 변환
scaled_scores = normalized_scores * 2 - 1

# 스케일링된 유사도 값을 딕셔너리로 저장
scaled_similarity_scores = {tag: score for tag, score in zip(similarity_scores.keys(), scaled_scores)}

# 스케일링된 유사도 값을 오름차순으로 정렬
sorted_scaled_similarity_scores = dict(sorted(scaled_similarity_scores.items(), key=lambda item: item[1]))

# 정렬된 결과 출력
sorted_scaled_similarity_scores

# 부정적인 감정과 긍정적인 감정을 나누어 유사도 점수 출력
negative_scaled_similarity_scores = {label: scaled_similarity_scores[label] for label in negative_emotions if label in scaled_similarity_scores}
positive_scaled_similarity_scores = {label: scaled_similarity_scores[label] for label in positive_emotions if label in scaled_similarity_scores}

# 유사도 점수 내림차순 정렬
sorted_negative_scores = dict(sorted(negative_scaled_similarity_scores.items(), key=lambda item: item[1], reverse=True))
sorted_positive_scores = dict(sorted(positive_scaled_similarity_scores.items(), key=lambda item: item[1], reverse=True))

print("부정적인 감정:")
for label, score in sorted_negative_scores.items():
    print(f"{label}: {score}")

print("\n긍정적인 감정:")
for label, score in sorted_positive_scores.items():
    print(f"{label}: {score}")

"""## 자체 데이터 8가지 라벨 코드"""

emotion_tags = ['실망','불편','속상','분노','공감','관심','편안함','신남']

# '설렘'과 다른 감정 태그의 임베딩
word_embedding = get_embedding('설렘')
emotion_embeddings = {tag: get_embedding(tag) for tag in emotion_tags}

# 유사도 계산
similarity_scores = {tag: cosine_similarity(word_embedding, embedding) for tag, embedding in emotion_embeddings.items()}

similarity_scores

"""- **높은 유사도** (0.7~1): 두 단어가 매우 유사한 의미를 갖고 있음을 나타냅니다.  
- **중간 유사도** (0.3~0.7): 두 단어가 어느 정도 유사하지만, 완전히 같은 의미는 아님을 나타냅니다.  
- **낮은 유사도** (0~0.3): 두 단어가 거의 유사하지 않음을 나타냅니다.
- **음수 유사도** (-1~0): 두 단어가 반대되는 의미를 가질 수 있음을 나타냅니다 (실제로 단어 임베딩에서는 거의 발생하지 않음).
"""

# 유사도 값을 1D numpy array로 변환
similarity_values = np.array([score.item() for score in similarity_scores.values()])

# 유사도 값을 0에서 1 사이로 정규화
min_val = np.min(similarity_values)
max_val = np.max(similarity_values)

normalized_scores = (similarity_values - min_val) / (max_val - min_val)

# 정규화된 값을 -1에서 1 사이로 변환
scaled_scores = normalized_scores * 2 - 1

# 스케일링된 유사도 값을 딕셔너리로 저장
scaled_similarity_scores = {tag: score for tag, score in zip(similarity_scores.keys(), scaled_scores)}

# 스케일링된 유사도 값을 오름차순으로 정렬
sorted_scaled_similarity_scores = dict(sorted(scaled_similarity_scores.items(), key=lambda item: item[1]))

# 정렬된 결과 출력
sorted_scaled_similarity_scores

"""### 워드 임베딩 다른 방식 시도"""

!pip install fasttext

import fasttext
import fasttext.util
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

# FastText 모델 로드
# 모델 파일 경로를 지정
model_path = 'path_to_your_fasttext_model/cc.ko.300.bin'
ft_model = fasttext.load_model(model_path)

# 단어 임베딩 함수
def get_fasttext_embedding(word):
    return ft_model.get_word_vector(word)

# 감정 태그 목록
emotion_tags = ['실망','불편','속상','분노','공감','관심','편안함','신남']

# '설렘'과 다른 감정 태그의 임베딩
word_embedding = get_fasttext_embedding('설렘')
emotion_embeddings = {tag: get_fasttext_embedding(tag) for tag in emotion_tags}

# 유사도 계산
similarity_scores = {tag: cosine_similarity([word_embedding], [embedding])[0][0] for tag, embedding in emotion_embeddings.items()}

print("Korean FastText 유사도:", similarity_scores)

import gensim.downloader as api
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

# Word2Vec 모델 로드
w2v_model = api.load("word2vec-google-news-300")

# 단어 임베딩 함수
def get_w2v_embedding(word):
    return w2v_model[word] if word in w2v_model else np.zeros((300,))

emotion_tags = ['실망','불편','속상','분노','공감','관심','편안함','신남']

# '설렘'과 다른 감정 태그의 임베딩
word_embedding = get_w2v_embedding('설렘')
emotion_embeddings = {tag: get_w2v_embedding(tag) for tag in emotion_tags}

# 유사도 계산
similarity_scores = {tag: cosine_similarity([word_embedding], [embedding])[0][0] for tag, embedding in emotion_embeddings.items()}

print("Word2Vec 유사도:", similarity_scores)



"""## 기존 코드"""

from transformers import BertTokenizer, BertModel
import torch
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

# BERT 모델과 토크나이저 로드
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertModel.from_pretrained('bert-base-uncased')

# 단어 임베딩 함수
def get_embedding(word):
    inputs = tokenizer(word, return_tensors='pt')
    outputs = model(**inputs)
    return outputs.last_hidden_state.mean(dim=1).detach().numpy()

emotion_tags = ['실망','불편','속상','분노','공감','관심','편안함','신남']

# '설렘'과 다른 감정 태그의 임베딩
word_embedding = get_embedding('설렘')
emotion_embeddings = {tag: get_embedding(tag) for tag in emotion_tags}

# 유사도 계산
similarity_scores = {tag: cosine_similarity(word_embedding, embedding) for tag, embedding in emotion_embeddings.items()}

print(similarity_scores)

# 유사도 값을 1D numpy array로 변환
similarity_values = np.array([score.item() for score in similarity_scores.values()])

# 유사도 값을 0에서 1 사이로 정규화
min_val = np.min(similarity_values)
max_val = np.max(similarity_values)

normalized_scores = (similarity_values - min_val) / (max_val - min_val)

# 정규화된 값을 -1에서 1 사이로 변환
scaled_scores = normalized_scores * 2 - 1

# 스케일링된 유사도 값을 딕셔너리로 저장
scaled_similarity_scores = {tag: score for tag, score in zip(similarity_scores.keys(), scaled_scores)}

scaled_similarity_scores

